<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phoenix Urban Heat Island Data Studio</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --panel:#0f1a2e;
      --panel2:#101f38;
      --text:#e9eefc;
      --muted:#a9b7dd;
      --accent:#66b3ff;
      --border:rgba(255,255,255,.10);
      --good:#7ee787;
      --warn:#f7c843;
      --bad:#ff7b72;

      --heatGreen:#3ddc84;
      --heatYellow:#f7c843;
      --heatOrange:#ff9f43;
      --heatRed:#ff5d5d;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background:linear-gradient(180deg,#070b14 0%, #0b1220 40%, #070b14 100%);
      color:var(--text);
    }
    header{
      padding:16px 18px 10px;
      border-bottom:1px solid var(--border);
      background:rgba(0,0,0,.25);
      position:sticky; top:0; z-index:5;
      backdrop-filter: blur(10px);
    }
    header h1{
      margin:0 0 6px;
      font-size:18px;
      letter-spacing:.2px;
    }
    header p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }

    .wrap{
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:12px;
      padding:12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; }
    }

    .panel{
      background:linear-gradient(180deg,var(--panel) 0%, var(--panel2) 100%);
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .panel .hd{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--border);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    .panel .hd h2{
      margin:0;
      font-size:14px;
      letter-spacing:.2px;
    }
    .panel .bd{
      padding:12px;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .row > *{ flex: 1 1 auto; }

    label{ display:block; font-size:12px; color:var(--muted); margin:0 0 6px; }
    input[type="date"], input[type="range"], select, button{
      width:100%;
      background:rgba(255,255,255,.06);
      border:1px solid var(--border);
      color:var(--text);
      padding:9px 10px;
      border-radius:10px;
      outline:none;
    }
    input[type="range"]{ padding:0; height:34px; }
    button{
      cursor:pointer;
      background:rgba(102,179,255,.15);
      border:1px solid rgba(102,179,255,.35);
      font-weight:600;
    }
    button:hover{ filter:brightness(1.08); }

    .kvs{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .kv{
      padding:10px;
      border:1px solid var(--border);
      border-radius:12px;
      background:rgba(0,0,0,.18);
    }
    .kv .k{ font-size:11px; color:var(--muted); margin-bottom:6px; }
    .kv .v{ font-size:14px; font-weight:700; }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.18);
      font-size:12px;
      color:var(--muted);
    }
    .statusDot{
      width:8px; height:8px; border-radius:50%;
      background:rgba(255,255,255,.35);
      display:inline-block;
    }
    .statusDot.ok{ background: var(--good); }
    .statusDot.warn{ background: var(--warn); }
    .statusDot.bad{ background: var(--bad); }

    #map{
      width:100%;
      height: 520px;
      border-radius:14px;
      overflow:hidden;
    }
    @media (max-width: 980px){
      #map{ height: 420px; }
    }

    .chartWrap{
      padding:12px;
      border-top:1px solid var(--border);
    }
    canvas{ background:rgba(0,0,0,.08); border:1px solid var(--border); border-radius:12px; }

    .note{
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
      margin-top:10px;
    }
    .small{ font-size:11px; color:var(--muted); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    /* Legend styling */
    .heat-legend{
      background:rgba(10,14,26,.90);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:10px 10px 8px;
      color:var(--text);
      font-size:12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .heat-legend .title{
      font-weight:800;
      font-size:12px;
      margin:0 0 6px;
    }
    .heat-legend .row{
      display:flex;
      gap:8px;
      align-items:center;
      margin:4px 0;
    }
    .swatch{
      width:14px; height:14px; border-radius:4px;
      border:1px solid rgba(255,255,255,.25);
    }
  </style>
</head>

<body>
<header>
  <h1>Phoenix Urban Heat Island Data Studio</h1>
  <p>
    Click anywhere on the map to investigate heat. Students can choose a baseline type, analyze <b>daytime highs</b> and <b>nighttime lows</b>,
    and make a mitigation decision supported by evidence.
  </p>
</header>

<div class="wrap">
  <!-- LEFT: Controls + Decision Panel -->
  <section class="panel">
    <div class="hd">
      <h2>Controls + Decision Studio</h2>
      <span class="pill"><span id="fetchDot" class="statusDot"></span><span id="fetchText">Ready</span></span>
    </div>

    <div class="bd">
      <div class="row">
        <div>
          <label for="lstDate">Map date (NASA LST overlay + Heat Visuals date)</label>
          <input type="date" id="lstDate" />
          <div class="small" style="margin-top:6px;">
            LST is satellite surface temperature context; Heat Visuals are daily max air temperature bins.
          </div>
        </div>
      </div>

      <hr style="border:0;border-top:1px solid var(--border);margin:12px 0">

      <div class="row">
        <div>
          <label for="baselineSelect">Baseline type (students choose)</label>
          <select id="baselineSelect">
            <option value="desert" selected>Desert baseline (low development)</option>
            <option value="suburban">Suburban baseline (Buckeye area)</option>
            <option value="downtown">Downtown baseline (Phoenix core)</option>
          </select>
          <div class="small" style="margin-top:6px;">
            UHI effects often show up more clearly in <b>warm nighttime lows</b> than daytime highs.
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label for="heatOn">Heat visuals (air temp max colors)</label>
          <select id="heatOn">
            <option value="off">Off</option>
            <option value="on" selected>On</option>
          </select>
        </div>
        <div>
          <label for="gridSize">Heat grid density</label>
          <select id="gridSize">
            <option value="4">Fast (4×4)</option>
            <option value="5" selected>Balanced (5×5)</option>
            <option value="6">Detailed (6×6)</option>
          </select>
        </div>
      </div>

      <div class="kvs">
        <div class="kv">
          <div class="k">Selected location</div>
          <div class="v mono" id="locText">Click the map</div>
        </div>
        <div class="kv">
          <div class="k">Baseline location</div>
          <div class="v mono" id="baselineText">—</div>
        </div>
      </div>

      <!-- Daytime -->
      <div class="kvs">
        <div class="kv">
          <div class="k">Hottest-day avg (top 5% of daily highs) — selected</div>
          <div class="v" id="avgHotSelected">—</div>
        </div>
        <div class="kv">
          <div class="k">Hottest-day avg (top 5% of daily highs) — baseline</div>
          <div class="v" id="avgHotBaseline">—</div>
        </div>
      </div>

      <!-- Nighttime -->
      <div class="kvs">
        <div class="kv">
          <div class="k">Warmest-night avg (top 5% of daily lows) — selected</div>
          <div class="v" id="avgWarmNightSelected">—</div>
        </div>
        <div class="kv">
          <div class="k">Warmest-night avg (top 5% of daily lows) — baseline</div>
          <div class="v" id="avgWarmNightBaseline">—</div>
        </div>
      </div>

      <div class="kvs">
        <div class="kv">
          <div class="k">Day UHI gap (highs: selected − baseline)</div>
          <div class="v" id="uhiGapDay">—</div>
        </div>
        <div class="kv">
          <div class="k">Night UHI gap (lows: selected − baseline)</div>
          <div class="v" id="uhiGapNight">—</div>
        </div>
      </div>

      <div class="kvs">
        <div class="kv">
          <div class="k">Heat Risk (simple model)</div>
          <div class="v" id="riskLevel">—</div>
        </div>
        <div class="kv">
          <div class="k">Revised Heat Risk (with mitigation)</div>
          <div class="v" id="riskAfter">—</div>
        </div>
      </div>

      <hr style="border:0;border-top:1px solid var(--border);margin:12px 0">

      <h2 style="margin:0 0 10px; font-size:14px;">Mitigation Simulator (student-facing)</h2>

      <div class="row">
        <div>
          <label for="trees">Increase tree canopy (%)</label>
          <input type="range" id="trees" min="0" max="40" step="1" value="10" />
          <div class="small"><span id="treesVal">10</span>%</div>
        </div>
        <div>
          <label for="coolroofs">Cool roofs / reflective surfaces (%)</label>
          <input type="range" id="coolroofs" min="0" max="60" step="1" value="15" />
          <div class="small"><span id="coolVal">15</span>%</div>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label for="impervious">Reduce dark pavement / impervious surface (%)</label>
          <input type="range" id="impervious" min="0" max="35" step="1" value="5" />
          <div class="small"><span id="impVal">5</span>%</div>
        </div>
      </div>

      <div class="kvs">
        <div class="kv">
          <div class="k">Estimated peak reduction (high temp)</div>
          <div class="v" id="mitigationDeltaHigh">—</div>
          <div class="small">Simplified classroom model (not a forecast).</div>
        </div>
        <div class="kv">
          <div class="k">Estimated night reduction (low temp)</div>
          <div class="v" id="mitigationDeltaLow">—</div>
          <div class="small">Night heat often lingers more in urban areas.</div>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="copyClaim">Copy a data-informed claim</button>
      </div>

      <div class="note">
        <strong>Data sources:</strong> Open-Meteo archive (reanalysis daily max/min temps) + NASA GIBS LST tiles (visual context).
      </div>

      <div class="note small">
        If the NASA overlay is blank, try changing <span class="mono">GIBS_TILE_MATRIXSET</span> in the code:
        <span class="mono">GoogleMapsCompatible_Level6</span>, <span class="mono">_Level7</span>, <span class="mono">_Level8</span>, or <span class="mono">_Level9</span>.
      </div>
    </div>
  </section>

  <!-- RIGHT: Map + Charts -->
  <section class="panel">
    <div class="hd">
      <h2>Map + Data Explorer</h2>
      <span class="pill"><span class="statusDot ok"></span>Click a location to load last 5 years</span>
    </div>

    <div class="bd">
      <div id="map"></div>
    </div>

    <div class="chartWrap">
      <h2 style="margin:0 0 10px; font-size:14px;">5-Year Daily Temperatures (Selected vs Baseline)</h2>
      <canvas id="tempChart" height="120"></canvas>

      <div class="note">
        Interpretation prompt: Where do you see the biggest difference—<b>day highs</b> or <b>night lows</b>? Use evidence to explain why.
      </div>
    </div>
  </section>
</div>

<script>
  /******************************************************************
   * Phoenix Urban Heat Island Data Studio (Baseline choice + Night metric)
   * - Baseline dropdown (desert/suburban/downtown)
   * - Open-Meteo daily max + min (5 years)
   * - Day UHI gap uses hottest-day avg (top 5% highs)
   * - Night UHI gap uses warmest-night avg (top 5% lows)
   * - Heat visuals overlay uses daily max for selected date
   ******************************************************************/

  // ----------- CONFIG -----------
  const PHX_CENTER = { lat: 33.4484, lon: -112.0740 };

  // Baseline options (tunable):
  // Desert: outside the metro / lower development (northwest desert fringe)
  // Suburban: Buckeye area
  // Downtown: Phoenix core
  const BASELINES = {
    desert:  { lat: 33.8790, lon: -112.2600, label: "Desert baseline (NW desert fringe)" },
    suburban:{ lat: 33.3703, lon: -112.5838, label: "Suburban baseline (Buckeye area)" },
    downtown:{ lat: 33.4484, lon: -112.0740, label: "Downtown baseline (Phoenix core)" }
  };

  // NASA GIBS WMTS REST pattern (Web Mercator)
  const GIBS_ENDPOINT = "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best";
  const GIBS_LAYER = "MODIS_Terra_Land_Surface_Temp_Day";
  const GIBS_TILE_MATRIXSET = "GoogleMapsCompatible_Level7";
  const GIBS_FORMAT_EXT = "png";

  // Open-Meteo Archive API
  const OPEN_METEO_ARCHIVE = "https://archive-api.open-meteo.com/v1/archive";

  function isoDate(d){ return d.toISOString().slice(0,10); }
  function addYears(date, years){
    const d = new Date(date);
    d.setFullYear(d.getFullYear() + years);
    return d;
  }
  function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

  const today = new Date();
  const fiveYearsAgo = addYears(today, -5);

  // ----------- UI refs -----------
  const fetchDot = document.getElementById("fetchDot");
  const fetchText = document.getElementById("fetchText");
  const lstDateInput = document.getElementById("lstDate");

  const baselineSelect = document.getElementById("baselineSelect");
  const baselineText = document.getElementById("baselineText");
  const locText = document.getElementById("locText");

  const avgHotSelected = document.getElementById("avgHotSelected");
  const avgHotBaseline = document.getElementById("avgHotBaseline");
  const avgWarmNightSelected = document.getElementById("avgWarmNightSelected");
  const avgWarmNightBaseline = document.getElementById("avgWarmNightBaseline");
  const uhiGapDay = document.getElementById("uhiGapDay");
  const uhiGapNight = document.getElementById("uhiGapNight");

  const riskLevel = document.getElementById("riskLevel");
  const riskAfter = document.getElementById("riskAfter");

  const mitigationDeltaHigh = document.getElementById("mitigationDeltaHigh");
  const mitigationDeltaLow = document.getElementById("mitigationDeltaLow");

  const trees = document.getElementById("trees");
  const coolroofs = document.getElementById("coolroofs");
  const impervious = document.getElementById("impervious");
  const treesVal = document.getElementById("treesVal");
  const coolVal = document.getElementById("coolVal");
  const impVal = document.getElementById("impVal");

  const copyClaimBtn = document.getElementById("copyClaim");

  // Heat visuals controls
  const heatOn = document.getElementById("heatOn");
  const gridSize = document.getElementById("gridSize");

  // Default date to ~3 days ago
  const lstDefault = new Date();
  lstDefault.setDate(lstDefault.getDate() - 3);
  lstDateInput.value = isoDate(lstDefault);

  // Current baseline
  let baselineKey = baselineSelect.value;
  let baseline = BASELINES[baselineKey];

  function updateBaselineUI(){
    baselineKey = baselineSelect.value;
    baseline = BASELINES[baselineKey];
    baselineText.textContent = `${baseline.label}`;
  }
  updateBaselineUI();

  // ----------- MAP -----------
  const map = L.map("map", { zoomControl: true }).setView([PHX_CENTER.lat, PHX_CENTER.lon], 10);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  function gibsUrlForDate(yyyy_mm_dd){
    return `${GIBS_ENDPOINT}/${GIBS_LAYER}/default/${yyyy_mm_dd}/${GIBS_TILE_MATRIXSET}/{z}/{y}/{x}.${GIBS_FORMAT_EXT}`;
  }

  let gibsLayer = L.tileLayer(gibsUrlForDate(lstDateInput.value), {
    opacity: 0.70,
    maxZoom: 9,
    attribution: 'NASA GIBS (Land Surface Temperature)'
  }).addTo(map);

  // Baseline marker
  let baselineMarker = L.circleMarker([baseline.lat, baseline.lon], {
    radius: 6, weight: 2, color: "#66b3ff", fillColor:"#66b3ff", fillOpacity: 0.25
  }).addTo(map).bindPopup("");

  function refreshBaselineMarker(){
    baselineMarker.setLatLng([baseline.lat, baseline.lon]);
    baselineMarker.bindPopup(`<b>Baseline:</b> ${baseline.label}<br>${baseline.lat.toFixed(4)}, ${baseline.lon.toFixed(4)}`);
  }
  refreshBaselineMarker();

  let selectedMarker = null;
  let selectedLatLon = null;

  // ----------- CHART -----------
  const tempChart = new Chart(document.getElementById("tempChart"), {
    type: "line",
    data: {
      labels: [],
      datasets: [
        { label: "Selected: Daily High (°F)", data: [], borderWidth: 2, pointRadius: 0, tension: 0.15 },
        { label: "Baseline: Daily High (°F)", data: [], borderWidth: 2, pointRadius: 0, tension: 0.15 },
        { label: "Selected: Daily Low (°F)", data: [], borderWidth: 2, pointRadius: 0, tension: 0.15 },
        { label: "Baseline: Daily Low (°F)", data: [], borderWidth: 2, pointRadius: 0, tension: 0.15 }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { labels: { color: "#e9eefc" } },
        tooltip: { mode: "index", intersect: false }
      },
      scales: {
        x: { ticks: { color: "#a9b7dd", maxTicksLimit: 8 }, grid: { color: "rgba(255,255,255,.06)" } },
        y: { ticks: { color: "#a9b7dd" }, grid: { color: "rgba(255,255,255,.06)" } }
      }
    }
  });

  // ----------- STATUS -----------
  function setStatus(state, text){
    fetchText.textContent = text;
    fetchDot.className = "statusDot";
    if(state === "ok") fetchDot.classList.add("ok");
    if(state === "warn") fetchDot.classList.add("warn");
    if(state === "bad") fetchDot.classList.add("bad");
  }

  // ----------- OPEN-METEO HELPERS -----------
  async function fetchOpenMeteoDailyMaxMin(lat, lon, start, end){
    const url = new URL(OPEN_METEO_ARCHIVE);
    url.searchParams.set("latitude", lat);
    url.searchParams.set("longitude", lon);
    url.searchParams.set("start_date", start);
    url.searchParams.set("end_date", end);
    url.searchParams.set("daily", "temperature_2m_max,temperature_2m_min");
    url.searchParams.set("temperature_unit", "fahrenheit");
    url.searchParams.set("timezone", "auto");

    const res = await fetch(url.toString());
    if(!res.ok) throw new Error(`Open-Meteo request failed: ${res.status}`);
    const json = await res.json();
    const times = json?.daily?.time || [];
    const tmax = json?.daily?.temperature_2m_max || [];
    const tmin = json?.daily?.temperature_2m_min || [];
    return { times, tmax, tmin };
  }

  async function fetchOpenMeteoDailyMaxForOneDay(lat, lon, dateStr){
    const url = new URL(OPEN_METEO_ARCHIVE);
    url.searchParams.set("latitude", lat);
    url.searchParams.set("longitude", lon);
    url.searchParams.set("start_date", dateStr);
    url.searchParams.set("end_date", dateStr);
    url.searchParams.set("daily", "temperature_2m_max");
    url.searchParams.set("temperature_unit", "fahrenheit");
    url.searchParams.set("timezone", "auto");

    const res = await fetch(url.toString());
    if(!res.ok) throw new Error(`Open-Meteo (one-day) failed: ${res.status}`);
    const json = await res.json();
    const tmax = json?.daily?.temperature_2m_max?.[0];
    return (typeof tmax === "number" && !Number.isNaN(tmax)) ? tmax : null;
  }

  function topPercentAverage(arr, topFraction){
    const clean = arr.filter(v => typeof v === "number" && !Number.isNaN(v));
    if(clean.length < 10) return null;
    const sorted = [...clean].sort((a,b)=>a-b);
    const topCount = Math.max(1, Math.floor(sorted.length * topFraction));
    const top = sorted.slice(sorted.length - topCount);
    return top.reduce((s,v)=>s+v,0) / top.length;
  }

  // ----------- RISK + MITIGATION -----------
  function classifyHeatRisk(peakHighF, warmNightLowF, nightGapF){
    // Student-facing, transparent model:
    // - Peak highs drive immediate danger
    // - Warm nights reduce recovery + increase cumulative stress
    // - Night UHI gap suggests retained heat in built areas
    if(peakHighF == null || warmNightLowF == null) return "—";

    let score = 0;

    // Peak high
    if(peakHighF >= 115) score += 3;
    else if(peakHighF >= 105) score += 2;
    else if(peakHighF >= 95) score += 1;

    // Warm nights
    if(warmNightLowF >= 90) score += 3;
    else if(warmNightLowF >= 85) score += 2;
    else if(warmNightLowF >= 80) score += 1;

    // Retained heat signal (optional)
    if(nightGapF != null){
      if(nightGapF >= 6) score += 2;
      else if(nightGapF >= 3) score += 1;
    }

    if(score >= 7) return "Extreme";
    if(score >= 5) return "High";
    if(score >= 3) return "Moderate";
    return "Low";
  }

  function mitigationModelDeltaHighF(){
    // very simplified effect sizes — "what-if" reasoning, not forecasting
    const t = Number(trees.value);
    const c = Number(coolroofs.value);
    const i = Number(impervious.value);
    const delta = (t * 0.08) + (c * 0.05) + (i * 0.07);
    return Math.min(8, Math.max(0, delta));
  }

  function mitigationModelDeltaLowF(deltaHigh){
    // nights often cool less than days from the same interventions; scale down
    return Math.max(0, Math.min(5, deltaHigh * 0.6));
  }

  function updateMitigationOutputs(){
    treesVal.textContent = trees.value;
    coolVal.textContent = coolroofs.value;
    impVal.textContent = impervious.value;

    const peakHigh = window.__peakHighF ?? null;
    const warmNight = window.__warmNightLowF ?? null;
    const nightGap = window.__nightGapF ?? null;

    if(peakHigh == null || warmNight == null){
      mitigationDeltaHigh.textContent = "—";
      mitigationDeltaLow.textContent = "—";
      riskAfter.textContent = "—";
      return;
    }

    const dHigh = mitigationModelDeltaHighF();
    const dLow = mitigationModelDeltaLowF(dHigh);

    mitigationDeltaHigh.textContent = `−${dHigh.toFixed(1)}°F`;
    mitigationDeltaLow.textContent = `−${dLow.toFixed(1)}°F`;

    const newHigh = peakHigh - dHigh;
    const newLow = warmNight - dLow;

    riskAfter.textContent = classifyHeatRisk(newHigh, newLow, nightGap);
  }

  [trees, coolroofs, impervious].forEach(el => el.addEventListener("input", updateMitigationOutputs));

  // ----------- HEAT VISUALS OVERLAY (GREEN→RED) -----------
  let heatLayerGroup = L.layerGroup().addTo(map);
  let legendControl = null;

  function clearHeatVisuals(){
    heatLayerGroup.clearLayers();
    if(legendControl){
      map.removeControl(legendControl);
      legendControl = null;
    }
  }

  function tempToColorF(tempF){
    // Phoenix-friendly bins:
    if(tempF == null) return "rgba(255,255,255,.0)";
    if(tempF < 90) return getComputedStyle(document.documentElement).getPropertyValue("--heatGreen").trim();
    if(tempF < 100) return getComputedStyle(document.documentElement).getPropertyValue("--heatYellow").trim();
    if(tempF < 110) return getComputedStyle(document.documentElement).getPropertyValue("--heatOrange").trim();
    return getComputedStyle(document.documentElement).getPropertyValue("--heatRed").trim();
  }

  function addLegend(){
    if(legendControl) return;
    legendControl = L.control({ position: "bottomright" });
    legendControl.onAdd = function(){
      const div = L.DomUtil.create("div", "heat-legend");
      div.innerHTML = `
        <div class="title">Heat Visuals (Daily Max Air Temp)</div>
        <div class="row"><span class="swatch" style="background:var(--heatGreen)"></span><span>&lt; 90°F</span></div>
        <div class="row"><span class="swatch" style="background:var(--heatYellow)"></span><span>90–99°F</span></div>
        <div class="row"><span class="swatch" style="background:var(--heatOrange)"></span><span>100–109°F</span></div>
        <div class="row"><span class="swatch" style="background:var(--heatRed)"></span><span>110°F+</span></div>
        <div class="small" style="margin-top:6px;opacity:.85;">Date: <span class="mono">${lstDateInput.value}</span></div>
      `;
      return div;
    };
    legendControl.addTo(map);
  }

  function updateLegendDate(){
    if(!legendControl) return;
    map.removeControl(legendControl);
    legendControl = null;
    addLegend();
  }

  async function refreshHeatVisuals(centerLat, centerLon){
    if(heatOn.value !== "on") return;

    clearHeatVisuals();
    addLegend();

    const n = Number(gridSize.value);
    const bounds = map.getBounds();

    const latMin = bounds.getSouth();
    const latMax = bounds.getNorth();
    const lonMin = bounds.getWest();
    const lonMax = bounds.getEast();

    const latSpan = clamp(latMax - latMin, 0.10, 2.50);
    const lonSpan = clamp(lonMax - lonMin, 0.10, 2.50);

    const clatMin = clamp(latMin, centerLat - latSpan/2, centerLat + latSpan/2);
    const clatMax = clamp(latMax, centerLat - latSpan/2, centerLat + latSpan/2);
    const clonMin = clamp(lonMin, centerLon - lonSpan/2, centerLon + lonSpan/2);
    const clonMax = clamp(lonMax, centerLon - lonSpan/2, centerLon + lonSpan/2);

    const lats = [];
    const lons = [];
    for(let i=0; i<n; i++){
      const t = (i + 0.5) / n;
      lats.push(clatMin + (clatMax - clatMin) * t);
      lons.push(clonMin + (clonMax - clonMin) * t);
    }

    const zoom = map.getZoom();
    const radius = zoom >= 12 ? 14 : zoom >= 11 ? 12 : zoom >= 10 ? 10 : 8;

    setStatus("warn", "Building heat visuals…");

    const dateStr = lstDateInput.value;
    const tasks = [];
    for(const lat of lats){
      for(const lon of lons){
        tasks.push((async ()=>{
          try{
            const tmax = await fetchOpenMeteoDailyMaxForOneDay(lat, lon, dateStr);
            return { lat, lon, tmax };
          }catch{
            return { lat, lon, tmax: null };
          }
        })());
      }
    }

    const results = await Promise.all(tasks);
    for(const r of results){
      if(r.tmax == null) continue;
      const color = tempToColorF(r.tmax);
      const circle = L.circleMarker([r.lat, r.lon], {
        radius,
        color: "rgba(255,255,255,.25)",
        weight: 1,
        fillColor: color,
        fillOpacity: 0.65
      }).bindPopup(`<b>Daily max air temp:</b> ${r.tmax.toFixed(1)}°F<br><span class="mono">${dateStr}</span><br>${r.lat.toFixed(4)}, ${r.lon.toFixed(4)}`);
      heatLayerGroup.addLayer(circle);
    }

    updateLegendDate();
    setStatus("ok", "Updated");
  }

  map.on("zoomend", async ()=>{
    if(heatOn.value !== "on") return;
    if(selectedLatLon) await refreshHeatVisuals(selectedLatLon.lat, selectedLatLon.lon);
  });

  // ----------- INTERACTIONS -----------
  function resetSummaryFields(){
    avgHotSelected.textContent = "—";
    avgHotBaseline.textContent = "—";
    avgWarmNightSelected.textContent = "—";
    avgWarmNightBaseline.textContent = "—";
    uhiGapDay.textContent = "—";
    uhiGapNight.textContent = "—";
    riskLevel.textContent = "—";
    riskAfter.textContent = "—";
    mitigationDeltaHigh.textContent = "—";
    mitigationDeltaLow.textContent = "—";

    window.__peakHighF = null;
    window.__warmNightLowF = null;
    window.__dayGapF = null;
    window.__nightGapF = null;
  }

  async function recomputeWithCurrentSelection(){
    if(!selectedLatLon) return;
    // re-run the same click behavior for selected point
    await handleMapSelection(selectedLatLon.lat, selectedLatLon.lon);
  }

  baselineSelect.addEventListener("change", async () => {
    updateBaselineUI();
    refreshBaselineMarker();
    resetSummaryFields();
    setStatus("warn", "Baseline changed…");
    await recomputeWithCurrentSelection();
  });

  lstDateInput.addEventListener("change", async () => {
    const d = lstDateInput.value;
    gibsLayer.setUrl(gibsUrlForDate(d));
    if (selectedLatLon && heatOn.value === "on") {
      await refreshHeatVisuals(selectedLatLon.lat, selectedLatLon.lon);
    }
  });

  heatOn.addEventListener("change", async () => {
    if (heatOn.value === "off") {
      clearHeatVisuals();
    } else if (selectedLatLon) {
      await refreshHeatVisuals(selectedLatLon.lat, selectedLatLon.lon);
    }
  });

  gridSize.addEventListener("change", async () => {
    if (heatOn.value === "on" && selectedLatLon) {
      await refreshHeatVisuals(selectedLatLon.lat, selectedLatLon.lon);
    }
  });

  // Map click -> selection
  map.on("click", async (e) => {
    await handleMapSelection(e.latlng.lat, e.latlng.lng);
  });

  async function handleMapSelection(lat, lon){
    selectedLatLon = { lat, lon };

    if(selectedMarker) map.removeLayer(selectedMarker);
    selectedMarker = L.circleMarker([lat, lon], {
      radius: 7, weight: 2, color: "#ffffff", fillColor:"#ffffff", fillOpacity: 0.20
    }).addTo(map);

    locText.textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
    updateBaselineUI();
    refreshBaselineMarker();

    setStatus("warn", "Fetching 5-year highs + lows…");

    try{
      const start = isoDate(fiveYearsAgo);
      const end = isoDate(today);

      const [sel, base] = await Promise.all([
        fetchOpenMeteoDailyMaxMin(lat, lon, start, end),
        fetchOpenMeteoDailyMaxMin(baseline.lat, baseline.lon, start, end),
      ]);

      // Chart: 4 datasets
      tempChart.data.labels = sel.times;
      tempChart.data.datasets[0].data = sel.tmax;
      tempChart.data.datasets[1].data = base.tmax;
      tempChart.data.datasets[2].data = sel.tmin;
      tempChart.data.datasets[3].data = base.tmin;
      tempChart.update();

      // Daytime hottest-day avg (top 5% of highs)
      const hotSel = topPercentAverage(sel.tmax, 0.05);
      const hotBase = topPercentAverage(base.tmax, 0.05);

      avgHotSelected.textContent = hotSel == null ? "—" : `${hotSel.toFixed(1)}°F`;
      avgHotBaseline.textContent = hotBase == null ? "—" : `${hotBase.toFixed(1)}°F`;

      // Nighttime warmest-night avg (top 5% of lows)
      const warmNightSel = topPercentAverage(sel.tmin, 0.05);
      const warmNightBase = topPercentAverage(base.tmin, 0.05);

      avgWarmNightSelected.textContent = warmNightSel == null ? "—" : `${warmNightSel.toFixed(1)}°F`;
      avgWarmNightBaseline.textContent = warmNightBase == null ? "—" : `${warmNightBase.toFixed(1)}°F`;

      const dayGap = (hotSel != null && hotBase != null) ? (hotSel - hotBase) : null;
      const nightGap = (warmNightSel != null && warmNightBase != null) ? (warmNightSel - warmNightBase) : null;

      uhiGapDay.textContent = dayGap == null ? "—" : `${dayGap.toFixed(1)}°F`;
      uhiGapNight.textContent = nightGap == null ? "—" : `${nightGap.toFixed(1)}°F`;

      // Store for mitigation/risk
      window.__peakHighF = hotSel;
      window.__warmNightLowF = warmNightSel;
      window.__dayGapF = dayGap;
      window.__nightGapF = nightGap;

      riskLevel.textContent = classifyHeatRisk(hotSel, warmNightSel, nightGap);
      updateMitigationOutputs();

      // Heat visuals overlay
      if(heatOn.value === "on"){
        await refreshHeatVisuals(lat, lon);
      } else {
        clearHeatVisuals();
      }

      setStatus("ok", "Updated");
    }catch(err){
      console.error(err);
      setStatus("bad", "Error fetching data");
      resetSummaryFields();
      clearHeatVisuals();
      alert("Data fetch failed. Try clicking another point, or try again later.");
    }
  }

  // Copy claim button
  copyClaimBtn.addEventListener("click", async () => {
    const loc = locText.textContent;
    const baseLabel = baseline.label;
    const baseCoords = `${baseline.lat.toFixed(4)}, ${baseline.lon.toFixed(4)}`;
    const date = lstDateInput.value;

    const claim =
`Claim (Data-Informed):
At ${loc}, the hottest-day average (top 5% of daily highs) over the last 5 years is ${avgHotSelected.textContent}, compared to ${avgHotBaseline.textContent} for the baseline (${baseLabel}, ${baseCoords}). This gives a Day UHI gap of ${uhiGapDay.textContent}.

The warmest-night average (top 5% of daily lows) over the last 5 years is ${avgWarmNightSelected.textContent} at ${loc}, compared to ${avgWarmNightBaseline.textContent} at the baseline. This gives a Night UHI gap of ${uhiGapNight.textContent}, which can indicate retained heat in built areas.

Heat visuals (air temp max overlay) date:
${date}

Decision:
If we increase tree canopy to ${trees.value}%, cool-roof adoption to ${coolroofs.value}%, and reduce dark pavement by ${impervious.value}%, the model estimates a high-temp reduction of ${mitigationDeltaHigh.textContent} and a night-temp reduction of ${mitigationDeltaLow.textContent}. Revised risk: ${riskAfter.textContent}.

Evidence note:
Open-Meteo archive temperatures are reanalysis estimates; use them to compare patterns and differences rather than exact street-level readings.`;

    try{
      await navigator.clipboard.writeText(claim);
      setStatus("ok", "Claim copied!");
      setTimeout(() => setStatus("ok", "Updated"), 1200);
    }catch{
      alert("Copy failed. You can manually copy the claim from the browser console.");
      console.log(claim);
    }
  });

  // Initial status
  setStatus("ok", "Ready");
  updateMitigationOutputs();
</script>
</body>
</html>
